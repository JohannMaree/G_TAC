#include "generate.h"
#include "io/proxFiles.h"
#include "io/proxStrings.h"
#include "variable.h"
#include "gobjects/gobject.h"
#include "compile.h"

#include <sstream>

namespace ppro {

	//Generated Using VAR and IVAR command inputs
	std::string globals() {
		ind s = GRegister_Variables.size();
		std::ostringstream ss;
		for (ind i = 0; i < s; ++i) {

			if (GRegister_Variables[i]->type == 0) {
				variables::variable* v = (GRegister_Variables[i].get());
				ss << v->name << " = " << v->value << ";\n";
			}
			else if (GRegister_Variables[i]->type == 1) {//Type 1: Basic Interface Type
				variables::ivariable* v = static_cast<variables::ivariable*>(GRegister_Variables[i].get());
				ss << v->name << " = DefineNumber[";
				ss << v->value << ", ";
				if (v->menu.exists) {
					ss << "Name \"" << v->menu.value << "/" << v->description.value << "_" << v->name << "\",";
				}
				else {
					ss << "Name \"" << v->description.value << "\",";
				}
				ss << " Label \"" << v->name << "\"";
				ss << "];\n";
			}
			else if (GRegister_Variables[i]->type == 2) {//Type 2: Bounded Type
				variables::ivariable* v = static_cast<variables::ivariable*>(GRegister_Variables[i].get());
				ss << v->name << " = DefineNumber[";
				ss << v->value << ", ";
				if (v->menu.exists) {
					ss << "Name \"" << v->menu.value << "/" << v->description.value << "_" << v->name << "\",";
				}
				else {
					ss << "Name \"" << v->description.value << "\",";
				}
				ss << " Label \"" << v->name << "\"";
				if (v->bounds.max.exists) {
					ss << ", MAX " << v->bounds.max.value;
				}
				if (v->bounds.min.exists) {
					ss << ", MIN " << v->bounds.min.value;
				}
				if (v->bounds.step.exists) {
					ss << ", STEP " << v->bounds.step.value;
				}
				ss << "];\n";
			}
			else if (GRegister_Variables[i]->type == 3) {//Type 3:Choice Type
				variables::ivariable* v = static_cast<variables::ivariable*>(GRegister_Variables[i].get());
				ss << v->name << " = DefineNumber[";
				ss << v->value << ", ";
				if (v->menu.exists) {
					ss << "Name \"" << v->menu.value << "/" << v->description.value << "_" << v->name << "\",";
				}
				else {
					ss << "Name \"" << v->description.value << "\",";
				}
				ss << " Label \"" << v->name << "\"";
				ss << ", CHOICES{";
				for (ind j = 0; j < v->choices.size(); ++j) {
					ss << v->choices[j] << ",";
				}
				ss << "}";
				ss << "];\n";
			}
			else if (GRegister_Variables[i]->type == -1) {//Type 4:Pairs List Type
				variables::cvariable* v = static_cast<variables::cvariable*>(GRegister_Variables[i].get());
				ss << v->name << " = {";
				for (ind i = 0; i < v->spairs.size(); ++i) {
					ss << v->spairs[i].one << ", " << v->spairs[i].two;
					ss << ",\n\t\t";
				}
				ss.seekp(-4, ss.cur);
				ss << "};\n";
			}

		}
		ss << "\n" << std::endl;
		return ss.str();
	}
	
	//Generated Using RGN and GRGN command inputs
	std::string group() {
		std::stringstream ss;
		ss << "Group {\n";
		for (ind i = 0; i < GArr_Groups.size(); ++i) {
			if (!GArr_Groups[i].empty()) {
				ss << "\t" << GArr_Groups[i] << ";\n";
			}
			else {
				ss << "\n";
			}
		}
		ss << "}\n" << std::endl;
		return ss.str();
	}

	std::string function() {
		std::stringstream ss;
		ss << "Function {\n";
		for (ind i = 0; i < GArr_Functions.size(); ++i) {
			ss << "\t" << GArr_Functions[i] << ";\n";
		}
		ss << "}\n" << std::endl;
		return ss.str();
	}

	std::string constraint() {
		std::stringstream ss;
		ss << "Constraint {\n";
		for (ind i = 0; i < GArr_Constraints.size(); ++i) {
			gobject::Constraint* c = &(GArr_Constraints[i]);
			
			ss << "\t{ Name " << c->Name << "; ";
			ss << "Type " << c->Type << ";\n";

			ss << "\t\tCase {\n";
			for (ind j = 0; j < c->Cases.size(); ++j) {
				gobject::cCase* cc = &(c->Cases[j]);
				ss << "\t\t\t{ Region " << cc->Region << "; ";
				ss << "Value " << cc->Value << "; }\n";
			}
			ss << "\t\t}\n";
			ss << "\t}\n";
		}
		ss << "}\n" << std::endl;
		return ss.str();
	}

	//Autogenerated
	std::string functionspace() {
		std::stringstream ss;
		ss << "FunctionSpace {\n";
		for (ind i = 0; i < GArr_FunctionSpaces.size(); ++i) {
			gobject::FunctionSpace* fs = &(GArr_FunctionSpaces[i]);

			ss << "\t{ Name " << fs->Name << "; Type " << fs->Type << ";\n";
			ss << "\t\tBasisFunction {\n";
			for (ind j = 0; j < fs->BasisFunctions.size(); ++j) {
				ss << "\t\t\t{ Name " << fs->BasisFunctions[j].Name << "; ";
				ss << "NameOfCoef " << fs->BasisFunctions[j].NameOfCoef << "; ";
				ss << "Function " << fs->BasisFunctions[j].Function << "; ";
				ss << "Support " << fs->BasisFunctions[j].Support << "; ";
				ss << "Entity " << fs->BasisFunctions[j].Entity << "; ";
				ss << "}\n";
 			}
			ss << "\t\t}\n";

			if (fs->Subspaces.size() > 0) {			//If Subspaces exist
				ss << "\t\tSubSpace {\n";
				for (ind j = 0; j < fs->Subspaces.size(); ++j) {
					ss << "\t\t\t{ Name ";
					ss << fs->Subspaces[j].Name << "; ";
					ss << "NameOfBasisFunction {";
					ss << fs->Subspaces[j].NameOfBasisFunction << "}; ";
					ss << "}\n";
				}
				ss << "\t\t}\n";
			}

			if (fs->GlobalQuantities.size() > 0) {	//If GlobalQuantities exist
				ss << "\t\tGlobalQuantity {\n";
				for (ind j = 0; j < fs->GlobalQuantities.size(); ++j) {
					ss << "\t\t\t{ Name ";
					ss << fs->GlobalQuantities[j].Name << "; ";
					ss << "Type ";
					ss << fs->GlobalQuantities[j].Type << "; ";
					ss << "NameOfCoef ";
					ss << fs->GlobalQuantities[j].NameOfCoef << "; ";
					ss << "}\n";
				}
				ss << "\t\t}\n";
			}

			if (fs->Constraints.size() > 0) {		//If Constraints exist
				ss << "\t\tConstraint {\n";
				for (ind j = 0; j < fs->Constraints.size(); ++j) {
					ss << "\t\t\t{ NameOfCoef " << fs->Constraints[j].NameOfCoef << "; ";
					ss << "EntityType " << fs->Constraints[j].EntityType << "; ";
					ss << "NameOfConstraint " << fs->Constraints[j].NameOfConstraint << "; ";
					ss << "}\n";
					
				}
				ss << "\t\t}\n";
			}
			ss << "\t}\n";
			
		}
		ss << "}\n" << std::endl;
		return ss.str();
	}

	std::string jacobian() {
		std::stringstream ss;
		ss << "Jacobian {\n";
		for (ind i = 0; i < GArr_Jacobians.size(); ++i) {
			gobject::Jacobian* jac = &(GArr_Jacobians[i]);

			ss << "\t{ Name " << jac->Name << ";\n";
			for (ind j = 0; j < jac->Cases.size(); ++j) {
				gobject::jCase* jc = &(jac->Cases[j]);

				ss << "\t\tCase {\n";
				ss << "\t\t\t{ Region " << jc->Region << "; ";
				ss << "Jacobian " << jc->Jacobian << "; }\n";
				ss << "\t\t}\n";
			}

			ss << "\t}\n";
		}
		ss << "}\n" << std::endl;
		return ss.str();
	}

	std::string integration() {
		std::stringstream ss;
		ss << "Integration {\n";
		for (ind i = 0; i < GArr_Integrations.size(); ++i) {
			gobject::Integration* in = &(GArr_Integrations[i]);

			ss << "\t{ Name " << in->Name << "; \n";
			for (ind j = 0; j < in->iCases.size(); ++j) {
				gobject::iCase* ic = &(in->iCases[j]);

				ss << "\t\tCase {\n";
				ss << "\t\t\t{ Type " << ic->Type << ";\n";
				ss << "\t\t\t\tCase{\n";
				for (ind k = 0; k < ic->geoCases.size(); ++k) {
					gobject::geoCase* geo = &(ic->geoCases[k]);

					ss << "\t\t\t\t\t{ GeoElement " << geo->GeoElement << ";";
					if (geo->GeoElement.length() > 8) {
						ss << "\t";
					}
					else if (geo->GeoElement.length() > 6) {
						ss << "\t\t";
					}
					else {
						ss << "\t\t\t";
					}
					ss << "NumberOfPoints " << geo->NumberOfPoints << "; }\n";
				}
				ss << "\t\t\t\t}\n";
				ss << "\t\t\t}\n";
				ss << "\t\t}\n";
			}
			ss << "\t}\n";
		}
		ss << "}\n" << std::endl;
		return ss.str();
	}

	std::string formulation() {
		std::stringstream ss;
		ss << "Formulation {\n";
		for (ind i = 0; i < GArr_Formulations.size(); ++i) {
			gobject::Formulation* f = &(GArr_Formulations[i]);

			ss << "\t{ Name " << f->Name << "; Type " << f->Type << ";\n";

			ss << "\t\tQuantity {\n";
			for (ind j = 0; j < f->Quantities.size(); ++j) {
				gobject::formQuantity* fq = &(f->Quantities[j]);
				ss << "\t\t\t{ Name " << fq->Name << "; ";
				ss << "Type " << fq->Type << "; ";
				ss << "NameOfSpace " << fq->NameOfSpace << "; }\n";
			}
			ss << "\t\t}\n";

			ss << "\t\tEquation {\n";
			for (ind j = 0; j < f->Equations.size(); ++j) {
				gobject::formEquation* fe = &(f->Equations[j]);
				ss << "\t\t\t" << fe->EQType << " { ";
				ss << "[ " << fe->PDE << " ];\n";
				ss << "\t\t\t\tIn " << fe->DomainName << "; ";
				ss << "Jacobian " << fe->JacobianName << "; ";
				ss << "Integration " << fe->IntegrationName << "; ";
				ss << "}\n";
			}
			if (f->Globals.size() > 0) {	//If formulation Globals exist
				for (ind j = 0; j < f->Globals.size(); ++j) {
					ss << "\t\t\t" << f->Globals[j].GEQType << "{";
					ss << "[" << f->Globals[j].GEquation << "];";
					ss << "In " << f->Globals[j].DomainName << ";";
					ss << "}\n";
				}
			}
			ss << "\t\t}\n";
		}
		ss << "\t}\n";
		ss << "}\n" << std::endl;
		return ss.str();
	}

	std::string resolution() {
		std::stringstream ss;
		ss << "Resolution {\n";
		for (ind i = 0; i < GArr_Resolutions.size(); ++i) {
			gobject::Resolution* res = &(GArr_Resolutions[i]);
			ss << "\t{ Name " << res->Name << ";\n";
			for (ind j = 0; j < res->SystemOps.size(); ++j) {
				gobject::rSystemOps* sys = &(res->SystemOps[i]);

				ss << "\t\tSystem {\n";
				ss << "\t\t\t{ Name " << sys->Name << "; ";
				ss << "NameOfFormulation " << sys->NameOfFormulation << "; ";
				ss << "}\n";
				ss << "\t\t}\n";

				ss << "\t\tOperation {\n";
				for (ind k = 0; k < sys->Operations.size(); ++k) {
					std::string top = sys->Operations[k];
					if (top.empty()) {
						ss << "\n";
					}
					else if (top.back() == '{' || top.back() == '}') {
						ss << "\t\t\t" << top << "\n";
					}
					else {
						ss << "\t\t\t" << top << ";\n";
					}
				}
				ss << "\t\t}\n";
			}
			ss << "\t}\n";
		}
		ss << "}\n" << std::endl;
		return ss.str();
	}

	//Generated Auto and Using POST commands
	std::string postprocessing() {
		std::stringstream ss;
		ss << "PostProcessing {\n";
		for (ind i = 0; i < GArr_PostProcesses.size(); ++i) {
			gobject::PostProcessing* pp = &(GArr_PostProcesses[i]);

			ss << "\t{ Name " << pp->Name << "; ";
			ss << "NameOfFormulation " << pp->NameOfFormulation << ";\n";
			ss << "\t\tQuantity {\n";
			for (ind j = 0; j < pp->Quantities.size(); ++j) {
				gobject::postQuantity* pq = &(pp->Quantities[j]);

				ss << "\t\t\t{ Name " << pq->Name << "; Value {\n";
				ss << "\t\t\t\tTerm{[ " << pq->Term << " ]; ";
				ss << "In " << pq->Domain << "; ";
				ss << "Jacobian " << pq->Jacobian << "; }\n";
				ss << "\t\t\t}}\n";
			}
			ss << "\t\t}\n";
			ss << "\t}\n";
		}
		ss << "}\n" << std::endl;
		return ss.str();
	}
	
	std::string postoperation() {
		std::stringstream ss;
		ss << "PostOperation {\n";
		for (ind i = 0; i < GArr_PostOperations.size(); ++i) {
			gobject::PostOperation* pop = &(GArr_PostOperations[i]);

			ss << "\t{ Name " << pop->Name << "; ";
			ss << "NameOfPostProcessing " << pop->NameOfPostProcessing << ";\n";

			ss << "\t\tOperation {\n";
			for (ind j = 0; j < pop->Operations.size(); ++j) {
				gobject::postOp* op = &(pop->Operations[j]);
				ss << "\t\t\t" << op->OperationType << "[";
				for (ind k = 0; k < op->OperationArgs.size(); ++k) {
					ss << op->OperationArgs[k] << ", ";
				}
				ss.seekp(-2, ss.cur);
				ss << "];\n";
			}
			ss << "\t\t}\n";
			ss << "\t}\n";
		}
		ss << "}\n" << std::endl;
		return ss.str();
	}

}
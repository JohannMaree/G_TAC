#include "generate.h"
#include "proxFiles.h"
#include "proxStrings.h"
#include "variable.h"
#include "gobject.h"
#include "compile.h"

#include <sstream>

namespace generate {

	//Generated Using VAR and IVAR command inputs
	std::string globals() {
		ind s = GRegister_Variables.size();
		std::ostringstream ss;
		for (ind i = 0; i < s; ++i) {
			if (GRegister_Variables[i]->type > 0) {
				variables::ivariable* v = static_cast<variables::ivariable*>(GRegister_Variables[i].get());
				ss << v->name << " = DefineNumber["; //Type 1
				ss << v->value << ", ";
				if (v->menu.exists) {
					ss << "Name \"" << v->menu.value << "/" << v->description.value << "_" << v->name << "\",";
				}
				else {
					ss << "Name \"" << v->description.value << "\",";
				}
				ss << " Label \"" << v->name << "\"";
				if (v->type == 2) {			//Type 2: Bounded Type
					if (v->bounds.max.exists) {
						ss << ", MAX " << v->bounds.max.value;
					}
					if (v->bounds.min.exists) {
						ss << ", MIN " << v->bounds.min.value;
					}
					if (v->bounds.step.exists) {
						ss << ", STEP " << v->bounds.step.value;
					}
				}
				else if (v->type == 3) {	//Type 3:Choice Type
					ss << ", CHOICES{";
					for (ind j = 0; j < v->choices.size(); ++j) {
						ss << v->choices[j] << ",";
					}
					ss << "}";
				}
				ss << "];\n";
			}
			else {
				variables::variable* v = static_cast<variables::variable*>(GRegister_Variables[i].get());
				ss << v->name << " = " << v->value << ";\n";
			}
		}
		ss << "\n" << std::endl;
		return ss.str();
	}
	
	//Generated Using RGN and GRGN command inputs
	std::string group() {
		std::stringstream ss;
		ss << "Group {\n";
		for (ind i = 0; i < GArr_Groups.size(); ++i) {
			ss << "\t" << GArr_Groups[i] << ";\n";
		}
		ss << "}\n" << std::endl;
		return ss.str();
	}

	std::string function() {
		std::stringstream ss;
		ss << "Function {\n";
		for (ind i = 0; i < GArr_Functions.size(); ++i) {
			ss << "\t" << GArr_Functions[i] << ";\n";
		}
		ss << "}\n" << std::endl;
		return ss.str();
	}

	std::string constraint() {
		std::stringstream ss;
		ss << "Constraint {\n";
		for (ind i = 0; i < GArr_Constraints.size(); ++i) {
			gobject::Constraint* c = &(GArr_Constraints[i]);
			
			ss << "\t{ Name " << c->Name << "; ";
			ss << "Type " << c->Type << ";\n";

			ss << "\t\tCase {\n";
			for (ind j = 0; j < c->Cases.size(); ++j) {
				gobject::cCase* cc = &(c->Cases[j]);
				ss << "\t\t\t{ Region " << cc->Region << "; ";
				ss << "Value " << cc->Value << "; }\n";
			}
			ss << "\t\t}\n";
			ss << "\t}\n";
		}
		ss << "}\n" << std::endl;
		return ss.str();
	}

	//Autogenerated
	std::string functionspace() {
		std::stringstream ss;
		ss << "FunctionSpace {\n";
		for (ind i = 0; i < GArr_FunctionSpaces.size(); ++i) {
			gobject::FunctionSpace* fs = &(GArr_FunctionSpaces[i]);

			ss << "\t{ Name " << fs->Name << "; Type " << fs->Type << ";\n";
			for (ind j = 0; j < fs->BasisFunctions.size(); ++j) {
				gobject::fsBasisFunction* fsbf = &(fs->BasisFunctions[j]);

				ss << "\t\tBasisFunction {\n";
				ss << "\t\t\t{ Name " << fsbf->Name << "; ";
				ss << "NameOfCoef " << fsbf->NameOfCoef << "; ";
				ss << "Function " << fsbf->Function << "; ";
				ss << "Support " << fsbf->Support << "; ";
				ss << "Entity " << fsbf->Entity << "; ";
				ss << "}\n";
				ss << "\t\t}\n";
 			}
			if () {

			}
			for (ind j = 0; j < fs->Constraints.size(); ++j) {
				gobject::fsConstraint* fscs = &(fs->Constraints[j]);

				ss << "\t\tConstraint {\n";
				ss << "\t\t\t{ NameOfCoef " << fscs->NameOfCoef << "; ";
				ss << "EntityType " << fscs->EntityType << "; ";
				ss << "NameOfConstraint " << fscs->NameOfConstraint << "; ";
				ss << "}\n";
				ss << "\t\t}\n";
			}
			ss << "\t}\n";
		}
		ss << "}\n" << std::endl;
		return ss.str();
	}

	std::string jacobian() {
		std::stringstream ss;
		ss << "Jacobian {\n";
		for (ind i = 0; i < GArr_Jacobians.size(); ++i) {
			gobject::Jacobian* jac = &(GArr_Jacobians[i]);

			ss << "\t{ Name " << jac->Name << ";\n";
			for (ind j = 0; j < jac->Cases.size(); ++j) {
				gobject::jCase* jc = &(jac->Cases[j]);

				ss << "\t\tCase {\n";
				ss << "\t\t\t{ Region " << jc->Region << "; ";
				ss << "Jacobian " << jc->Jacobian << "; }\n";
				ss << "\t\t}\n";
			}

			ss << "\t}\n";
		}
		ss << "}\n" << std::endl;
		return ss.str();
	}

	std::string integration() {
		std::stringstream ss;
		ss << "Integration {\n";
		for (ind i = 0; i < GArr_Integrations.size(); ++i) {
			gobject::Integration* in = &(GArr_Integrations[i]);

			ss << "\t{ Name " << in->Name << "; \n";
			for (ind j = 0; j < in->iCases.size(); ++j) {
				gobject::iCase* ic = &(in->iCases[j]);

				ss << "\t\tCase {\n";
				ss << "\t\t\t{ Type " << ic->Type << ";\n";
				ss << "\t\t\t\tCase{\n";
				for (ind k = 0; k < ic->geoCases.size(); ++k) {
					gobject::geoCase* geo = &(ic->geoCases[k]);

					ss << "\t\t\t\t\t{ GeoElement " << geo->GeoElement << ";\t\t";
					ss << "NumberOfPoints " << geo->NumberOfPoints << "; }\n";
				}
				ss << "\t\t\t\t}\n";
				ss << "\t\t\t}\n";
				ss << "\t\t}\n";
			}
			ss << "\t}\n";
		}
		ss << "}\n" << std::endl;
		return ss.str();
	}

	std::string formulation() {
		std::stringstream ss;
		ss << "Formulation {\n";
		for (ind i = 0; i < GArr_Formulations.size(); ++i) {
			gobject::Formulation* f = &(GArr_Formulations[i]);

			ss << "\t{ Name " << f->Name << "; Type " << f->Type << ";\n";

			ss << "\t\tQuantity {\n";
			for (ind j = 0; j < f->Quantities.size(); ++j) {
				gobject::formQuantity* fq = &(f->Quantities[j]);
				ss << "\t\t\t{ Name " << fq->Name << "; ";
				ss << "Type " << fq->Type << "; ";
				ss << "NameOfSpace " << fq->NameOfSpace << "; }\n";
			}
			ss << "\t\t}\n";

			ss << "\t\tEquation {\n";
			for (ind j = 0; j < f->Equations.size(); ++j) {
				gobject::formEquation* fe = &(f->Equations[j]);
				ss << "\t\t\t" << fe->EQType << " { ";
				ss << "[ " << fe->PDE << " ];\n";
				ss << "\t\t\t\tIn " << fe->DomainName << "; ";
				ss << "Jacobian " << fe->JacobianName << "; ";
				ss << "Integration " << fe->IntegrationName << "; ";
				ss << "}\n";
			}
			ss << "\t\t}\n";
		}
		ss << "\t}\n";
		ss << "}\n" << std::endl;
		return ss.str();
	}

	std::string resolution() {
		std::stringstream ss;
		ss << "Resolution {\n";
		for (ind i = 0; i < GArr_Resolutions.size(); ++i) {
			gobject::Resolution* res = &(GArr_Resolutions[i]);
			ss << "\t{ Name " << res->Name << ";\n";
			for (ind j = 0; j < res->SystemOps.size(); ++j) {
				gobject::rSystemOps* sys = &(res->SystemOps[i]);

				ss << "\t\tSystem {\n";
				ss << "\t\t\t{ Name " << sys->Name << "; ";
				ss << "NameOfFormulation " << sys->NameOfFormulation << "; ";
				ss << "}\n";
				ss << "\t\t}\n";

				ss << "\t\tOperation {\n";
				for (ind k = 0; k < sys->Operations.size(); ++k) {
					ss << "\t\t\t" << sys->Operations[k] << ";\n";
				}
				ss << "\t\t}\n";
			}
			ss << "\t}\n";
		}
		ss << "}\n" << std::endl;
		return ss.str();
	}

	//Generated Auto and Using POST commands
	std::string postprocessing() {
		std::stringstream ss;
		ss << "PostProcessing {\n";
		for (ind i = 0; i < GArr_PostProcesses.size(); ++i) {
			gobject::PostProcessing* pp = &(GArr_PostProcesses[i]);

			ss << "\t{ Name " << pp->Name << "; ";
			ss << "NameOfFormulation " << pp->NameOfFormulation << ";\n";
			ss << "\t\tQuantity {\n";
			for (ind j = 0; j < pp->Quantities.size(); ++j) {
				gobject::postQuantity* pq = &(pp->Quantities[j]);

				ss << "\t\t\t{ Name " << pq->Name << "; Value {\n";
				ss << "\t\t\t\tTerm{[ " << pq->Term << " ]; ";
				ss << "In " << pq->Domain << "; ";
				ss << "Jacobian " << pq->Jacobian << "; }\n";
				ss << "\t\t\t}}\n";
			}
			ss << "\t\t}\n";
			ss << "\t}\n";
		}
		ss << "}\n" << std::endl;
		return ss.str();
	}
	
	std::string postoperation() {
		std::stringstream ss;
		ss << "PostOperation {\n";
		for (ind i = 0; i < GArr_PostOperations.size(); ++i) {
			gobject::PostOperation* pop = &(GArr_PostOperations[i]);

			ss << "\t{ Name " << pop->Name << "; ";
			ss << "NameOfPostProcessing " << pop->NameOfPostProcessing << ";\n";

			ss << "\t\tOperation {\n";
			for (ind j = 0; j < pop->Operations.size(); ++j) {
				gobject::postOp* op = &(pop->Operations[j]);
				ss << "\t\t\t" << op->OperationType << "[";
				for (ind k = 0; k < op->OperationArgs.size(); ++k) {
					ss << op->OperationArgs[k] << ", ";
				}
				ss.seekp(-2, ss.cur);
				ss << "];\n";
			}
			ss << "\t\t}\n";
			ss << "\t}\n";
		}
		ss << "}\n" << std::endl;
		return ss.str();
	}

}